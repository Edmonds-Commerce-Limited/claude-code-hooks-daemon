# Hooks Daemon Upgrade Feedback: v2.3.0 -> v2.9.0

**Date**: 2026-02-11
**Environment**: Fedora 42 (Linux 6.18.7), Python 3.9.21 (system default) / Python 3.13.11 (available)
**Project path**: `/var/www/vhosts/version_v2/green/product-data-api/` (deeply nested, 57 chars)
**Upgrading from**: v2.3.0 (no venv existed, no hooks-daemon.yaml existed)
**Upgrading to**: v2.9.0

---

## Summary

The upgrade completed but required significant manual intervention. The legacy upgrade path (Layer 1 fallback) does not handle several real-world scenarios. The documentation is thorough but some critical gaps exist.

---

## Issues Encountered (In Order)

### 1. No `hooks-daemon.yaml` at project root - detected but not repaired

**What happened**: The upgrade script correctly detected that the config file was missing and printed:
```
WARN Config file missing - will be repaired during upgrade
```

**But**: The legacy fallback path does NOT repair the config. It just does `git checkout` + `pip install` + daemon start. The "will be repaired" message is misleading because the Layer 2 script (which handles config repair) was not available at v2.3.0.

**Fix suggestion**: The legacy fallback in Layer 1 should generate a default config if none exists:
```bash
if [ ! -f "$PROJECT_ROOT/.claude/hooks-daemon.yaml" ]; then
    "$VENV_PYTHON" -c "from claude_code_hooks_daemon.daemon.init_config import generate_config; print(generate_config(mode='full'))" > "$PROJECT_ROOT/.claude/hooks-daemon.yaml"
fi
```

### 2. No virtual environment existed

**What happened**: The previous v2.3.0 installation had no venv at `.claude/hooks-daemon/untracked/venv/`. The upgrade script assumes a venv exists and tries to use it for `pip install` and daemon start/stop:

```bash
VENV_PIP="$(dirname "$VENV_PYTHON")/pip"
if [ -f "$VENV_PIP" ]; then
    "$VENV_PIP" install -e "$DAEMON_DIR" --quiet
fi
```

The `if [ -f "$VENV_PIP" ]` check means it silently skips installation when no venv exists. The daemon start then fails silently (the `|| true` swallows the error).

**Fix suggestion**: The legacy fallback should detect missing venv and create it:
```bash
if [ ! -f "$VENV_PYTHON" ]; then
    _info "Creating virtual environment..."
    python3 -m venv "$DAEMON_DIR/untracked/venv"
fi
```

### 3. Python version incompatibility (3.9 vs 3.11+ requirement)

**What happened**: System `python3` is 3.9.21. The daemon v2.9.0 requires `>=3.11` (from pyproject.toml). Creating the venv with `python3` and then running `pip install` produced:

```
ERROR: Package 'claude-code-hooks-daemon' requires a different Python: 3.9.21 not in '>=3.11'
```

Had to manually discover that `python3.13` was available and recreate the venv with that.

**Fix suggestion**: The upgrade script (and LLM-UPDATE.md) should:
1. Check the Python version requirement before attempting venv creation
2. Search for compatible Python versions (`python3.13`, `python3.12`, `python3.11`) if default `python3` is too old
3. Document the Python 3.11+ requirement prominently

Example check:
```bash
REQUIRED_PYTHON_MINOR=11
PYTHON_CMD="python3"
PYTHON_MINOR=$("$PYTHON_CMD" -c "import sys; print(sys.version_info.minor)" 2>/dev/null || echo 0)
if [ "$PYTHON_MINOR" -lt "$REQUIRED_PYTHON_MINOR" ]; then
    for ver in 3.13 3.12 3.11; do
        if command -v "python$ver" &>/dev/null; then
            PYTHON_CMD="python$ver"
            break
        fi
    done
fi
```

### 4. AF_UNIX socket path too long

**What happened**: The project is at a deeply nested path:
```
/var/www/vhosts/version_v2/green/product-data-api/.claude/hooks-daemon/untracked/daemon-bl-product-data.sock
```

This exceeds the Unix socket path limit (108 bytes on Linux). The daemon crashed with:
```
ERROR: Daemon crashed: AF_UNIX path too long
OSError: AF_UNIX path too long
```

**Workaround used**: Set environment variables to use `/tmp/` paths:
```bash
CLAUDE_HOOKS_SOCKET_PATH=/tmp/hooks-daemon-pda.sock
CLAUDE_HOOKS_PID_PATH=/tmp/hooks-daemon-pda.pid
CLAUDE_HOOKS_LOG_PATH=/tmp/hooks-daemon-pda.log
```

**Fix suggestion**:
1. The daemon should automatically detect when the default path would be too long and fall back to a shorter path (e.g., `/tmp/hooks-daemon-{hash}.sock` or `/run/user/{uid}/hooks-daemon-{hash}.sock`)
2. The error message should suggest the environment variable overrides
3. LLM-UPDATE.md should mention this as a known issue for deep paths
4. The hostname-based isolation docs mention sanitization but don't mention the path length limit

**Note**: The daemon's own docs say "NEVER use `/tmp` for runtime files (sockets, PID files, logs)" in Security Standards, but the environment variable overrides force using `/tmp/` when the default path is too long. This is a contradiction.

### 5. Duplicate priority warnings (cosmetic but noisy)

**What happened**: The default config generated by `generate_config(mode='full')` produces 18 duplicate priority warnings on every daemon start/stop/status command. This is because many handlers share the same priority (e.g., 6 handlers at priority 10, 3 at priority 15, etc.).

**Fix suggestion**: Either:
- Assign unique priorities in the default config template
- Suppress the warning when using alphabetical fallback (it's deterministic, so it's not actually a problem)
- Reduce the warning to DEBUG level since alphabetical ordering is documented behavior

### 6. Hook scripts not deployed by legacy upgrade

**What happened**: The existing `.claude/hooks/` directory contains standalone Python hook scripts (not daemon forwarders). The legacy upgrade path does not deploy the daemon's forwarder scripts. After upgrade, the daemon is running but not connected to Claude Code because there are no forwarder scripts calling it.

**Fix suggestion**: The legacy fallback should check if hook forwarder scripts need deployment, or at minimum warn:
```
WARN: Hook forwarder scripts not deployed. Run 'deploy_all_hooks' to connect daemon to Claude Code.
```

---

## Documentation Feedback

### LLM-UPDATE.md

**Strengths**:
- Very thorough and well-structured
- Multiple upgrade paths documented (recommended, manual, specific version)
- Good rollback documentation
- Helpful troubleshooting section

**Gaps**:

1. **No mention of Python version requirement**: The document never mentions that Python 3.11+ is required. This is critical for environments where system Python is older.

2. **No mention of socket path length limit**: Deep project paths will hit the AF_UNIX 108-byte limit. This should be in the Troubleshooting section.

3. **"Config file missing - will be repaired" is misleading**: The Layer 1 script prints this but the legacy fallback doesn't repair it. The message should say "will be repaired during upgrade (Layer 2 only)" or the legacy path should actually repair it.

4. **Verification steps assume daemon can start**: Step 4 verification (`$VENV_PYTHON -m claude_code_hooks_daemon.daemon.cli status`) will fail if any of the above issues prevent daemon startup. The verification should have troubleshooting branches.

5. **Missing "fresh install from existing checkout" path**: When upgrading from a version where venv/config don't exist (broken previous install), the update docs don't cover this. It falls between "fresh install" (LLM-INSTALL.md) and "update" (LLM-UPDATE.md).

6. **Post-update handler discovery assumes daemon is running**: Step 5 (Discover New Handlers) runs Python commands that import daemon modules, which requires the venv to be working. If the venv failed, these commands fail too.

### Layer 1 upgrade.sh Script

**Strengths**:
- Self-locating (walks up directory tree)
- Detects self-install mode
- Clean fallback to legacy flow

**Gaps**:

1. **Legacy fallback is too minimal**: It only does checkout + pip install + start. Missing:
   - Config generation/repair
   - Venv creation if missing
   - Python version checking
   - Hook forwarder deployment
   - Socket path validation

2. **Silent failures**: The `|| true` on daemon start swallows all errors. If the daemon can't start, the user sees "Legacy upgrade complete" with no indication of failure.

3. **No pre-flight checks**: The script doesn't verify Python version, disk space, or write permissions before starting the upgrade.

---

## Recommendations (Priority Order)

### P0 - Critical (upgrade will fail without these)

1. **Python version detection**: Check Python >= 3.11, search for alternatives if default is too old
2. **Socket path length detection**: Auto-shorten or use `/run/user/` when path exceeds 100 chars
3. **Venv creation in legacy fallback**: Create venv if it doesn't exist

### P1 - Important (upgrade succeeds but with manual steps)

4. **Config generation in legacy fallback**: Generate default config if missing
5. **Hook forwarder deployment in legacy fallback**: Deploy or warn about missing forwarders
6. **Better error reporting**: Don't swallow daemon start failures with `|| true`

### P2 - Nice to Have

7. **Deduplicate priorities in default config**: Assign unique priorities to avoid 18 warnings
8. **Add Python version requirement to LLM-UPDATE.md**
9. **Add socket path troubleshooting to LLM-UPDATE.md**
10. **Add "broken install recovery" section bridging install and update docs**

---

## Issue 7: Layer 1 Checks for Layer 2 BEFORE Checkout (Critical Script Bug)

### What happened

The upgrade script (`upgrade.sh` Line 112-116) checks whether `scripts/upgrade_version.sh` (Layer 2) exists **before** checking out the target version:

```bash
LAYER2_SCRIPT="$DAEMON_DIR/scripts/upgrade_version.sh"
if [ -f "$LAYER2_SCRIPT" ]; then
    exec bash "$LAYER2_SCRIPT" "$PROJECT_ROOT" "$DAEMON_DIR" "$TARGET_VERSION"
else
    # Legacy fallback...
    git -C "$DAEMON_DIR" checkout "$TARGET_VERSION" --quiet
```

At v2.3.0, `upgrade_version.sh` doesn't exist. So it falls to the legacy path, which does the checkout to v2.9.0. **After** checkout, `upgrade_version.sh` now exists in the v2.9.0 code - but the script never re-checks.

This means ANY upgrade from a pre-Layer-2 version ALWAYS hits the broken legacy path, regardless of the target version. The Layer 2 orchestrator (which handles venv creation, config generation, hook deployment, settings.json, etc.) is never invoked.

### Fix suggestion

Checkout first, THEN check for Layer 2:

```bash
# Checkout target FIRST
git -C "$DAEMON_DIR" checkout "$TARGET_VERSION" --quiet

# NOW check for Layer 2 in the new code
LAYER2_SCRIPT="$DAEMON_DIR/scripts/upgrade_version.sh"
if [ -f "$LAYER2_SCRIPT" ]; then
    exec bash "$LAYER2_SCRIPT" "$PROJECT_ROOT" "$DAEMON_DIR" "$TARGET_VERSION"
fi
```

### Impact

This is the ROOT CAUSE of most other issues. If Layer 2 ran, it would have:
- Created the venv
- Generated the config
- Deployed hook forwarders
- Updated settings.json
- Handled the socket path

The docs claim "This works for any version (including pre-v2.5.0 installations)" but this is false because the Layer 2 script is never reached from pre-Layer-2 versions.

---

## Issue 8: settings.json Not Mentioned Anywhere in Upgrade Docs

### What happened

Claude Code hooks require registration in `.claude/settings.json`. The daemon forwarder scripts deployed to `.claude/hooks/` do nothing unless settings.json references them. The entire LLM-UPDATE.md document never mentions settings.json at all.

After deploying all forwarder scripts and starting the daemon, hooks still didn't work because settings.json only referenced the old standalone Python scripts.

### Fix suggestion

The upgrade docs (and Layer 2 script) must include settings.json updates. At minimum, document what settings.json entries are needed for each hook event type.

---

## Issue 9: LLM-UPDATE.md Does Not Instruct LLM to Tell User to Restart Claude Code

### What happened

After the upgrade completed, the LLM (me) did not strongly tell the user to restart Claude Code. The user had to prompt me about it. The LLM-UPDATE.md document says:

> **No Claude Code restart needed.** Daemon restart is sufficient. Exception: Only if update adds NEW event types (new files in `.claude/hooks/`), then restart Claude Code.

This is buried as a side note. When upgrading from v2.3.0 to v2.9.0 (6 minor versions), it is almost guaranteed that new event types were added (e.g., `status-line`, `pre-compact`, `subagent-stop`, `stop`). The document should:

1. **Prominently instruct the LLM to tell the user to restart Claude Code** after any multi-version upgrade
2. Make it a numbered step in the verification process, not an "exception" footnote
3. Explain WHY: new hook event types won't be picked up until Claude Code restarts because it only reads `.claude/hooks/` at session start

### Fix suggestion

Add to the verification section (Step 4) as a mandatory final step:

```
### IMPORTANT: Restart Claude Code

After upgrading across multiple versions, you MUST restart Claude Code:
- New hook event types (status-line, pre-compact, etc.) are only loaded at session start
- The daemon is running but Claude Code won't call the new hooks until restarted
- **Tell the user clearly**: "Please restart Claude Code now to activate the new hooks"
```

The current wording "No Claude Code restart needed" is misleading for multi-version upgrades where new event types are almost certainly introduced.

---

## Environment Details for Reproduction

```
OS: Fedora 42 (Linux 6.18.7-100.fc42.x86_64)
Python (system): 3.9.21
Python (available): 3.13.11
Project path length: 57 chars
Full socket path length: ~110 chars (exceeds 108 AF_UNIX limit)
Previous daemon state: git repo at v2.3.0, no venv, no config, standalone hook scripts
```
